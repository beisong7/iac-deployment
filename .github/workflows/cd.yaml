name: Deploy Project Bedrock Infrastructure


on:
  push:
    branches: [ "main" ]

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  EC2_HOST: ${{ secrets.EC2_HOST }}
  EC2_USER: ${{ secrets.EC2_USER }}
  EC2_PRIVATE_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
  DEPLOYMENT_DIR: /home/ubuntu/project-bedrock
  TERRAFORM_DIR: terraform/eks/default
  ARCHIVE_NAME: project-bedrock.zip

permissions:
  contents: read
  pull-requests: write

jobs:
  # Deploy infrastructure and application (deploy branch only)
  deploy:
    name: ðŸš€ Deploy Infrastructure & Application
    timeout-minutes: 45 
    runs-on: ubuntu-latest
    steps:
      - name: Deploy infrastructure with Terraform
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USER }}
          key: ${{ env.EC2_PRIVATE_KEY }}
          port: 22
          debug: true
          script: |
            echo "Starting infrastructure deployment..."
            
            cd ${{ env.DEPLOYMENT_DIR }}/current
            
            # Configure AWS credentials
            export AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}"
            export AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}"
            export AWS_DEFAULT_REGION="${{ env.AWS_REGION }}"
            
            # Deploy infrastructure with Terraform
            cd ${{ env.TERRAFORM_DIR }}
            terraform init
            # terraform apply -auto-approve
            terraform apply -var="environment_name=store-retailed" -auto-approve
            
            # Get outputs and save deployment info
            terraform output -json > terraform_outputs.json
            
            # Update kubeconfig if EKS cluster exists
            if terraform output cluster_name &>/dev/null; then
              CLUSTER_NAME=$(terraform output -raw cluster_name)
              aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name $CLUSTER_NAME
              echo "CLUSTER_NAME=$CLUSTER_NAME" > ../deployment_info.txt
              
              # Get additional cluster info
              VPC_ID=$(terraform output -raw vpc_id 2>/dev/null || echo "N/A")
              echo "VPC_ID=$VPC_ID" >> ../deployment_info.txt
            fi
            
            echo "Infrastructure deployment completed successfully"

      - name: Deploy application to EKS cluster
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USER }}
          key: ${{ env.EC2_PRIVATE_KEY }}
          port: 22
          debug: true
          script: |
            echo "Starting application deployment..."
            
            cd ${{ env.DEPLOYMENT_DIR }}/current
            
            # Configure AWS and kubectl
            export AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}"
            export AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}"
            export AWS_DEFAULT_REGION="${{ env.AWS_REGION }}"
            
            # Check if EKS cluster exists
            if [ -f terraform/deployment_info.txt ]; then
              source terraform/deployment_info.txt
              
              echo "Waiting for cluster nodes to be ready..."
              kubectl wait --for=condition=Ready nodes --all --timeout=300s || echo "Some nodes may still be initializing"
              
              # Deploy application using Helm
              cd src/app
              
              if [ -d "chart" ]; then
                echo "Deploying retail store application with Helm..."
                helm upgrade --install retail-store ./chart \
                  --values values.yaml \
                  --wait --timeout=600s \
                  --create-namespace
                
                echo "Application deployed successfully"
              else
                echo "No Helm chart found, checking for Kubernetes manifests..."
                
                # Apply any kubernetes yaml files
                find . -name "*.yaml" -o -name "*.yml" | grep -E "(k8s|kubernetes)" | while read manifest; do
                  echo "Applying manifest: $manifest"
                  kubectl apply -f "$manifest"
                done
              fi
              
              # Get application status
              echo "Checking application status..."
              kubectl get pods -A
              kubectl get services
              
              # Try to get load balancer URL
              LB_URL=$(kubectl get svc ui -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "Service not found or no load balancer")
              echo "APP_URL=$LB_URL" >> ../terraform/deployment_info.txt
              
              echo "Application deployment completed successfully"
            else
              echo "No EKS cluster found, skipping application deployment"
            fi

      - name: Run post-deployment verification
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USER }}
          key: ${{ env.EC2_PRIVATE_KEY }}
          port: 22
          debug: true
          script: |
            echo "Running post-deployment verification..."
            
            cd ${{ env.DEPLOYMENT_DIR }}/current
            
            # Configure kubectl
            export AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}"
            export AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}"
            export AWS_DEFAULT_REGION="${{ env.AWS_REGION }}"
            
            if [ -f terraform/deployment_info.txt ]; then
              # Check pod status
              echo "Verifying pod status..."
              FAILED_PODS=$(kubectl get pods -A --field-selector=status.phase!=Running --no-headers | wc -l)
              
              if [ "$FAILED_PODS" -eq 0 ]; then
                echo "All pods are running successfully"
              else
                echo "Warning: $FAILED_PODS pods are not in Running state"
                kubectl get pods -A --field-selector=status.phase!=Running
              fi
              
              # Test service connectivity
              echo "Testing service connectivity..."
              kubectl get endpoints
              
              echo "Post-deployment verification completed"
            else
              echo "No cluster deployed, skipping verification"
            fi

      - name: Create deployment summary
        run: |
          # Configure SSH for getting deployment info
          mkdir -p ~/.ssh
          echo "${{ env.EC2_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.EC2_HOST }} >> ~/.ssh/known_hosts
          
          # Get deployment information from management instance
          DEPLOYMENT_INFO=$(ssh -i ~/.ssh/id_rsa ${{ env.EC2_USER }}@${{ env.EC2_HOST }} "cat ${{ env.DEPLOYMENT_DIR }}/current/terraform/deployment_info.txt 2>/dev/null || echo 'No deployment info available'")
          
          echo "## ðŸš€ Deployment Completed Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** âœ… Infrastructure and Application Deployed" >> $GITHUB_STEP_SUMMARY
          echo "**Archive:** ${{ needs.build.outputs.archive-name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Size:** ${{ needs.build.outputs.archive-size }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“‹ Infrastructure Details" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "$DEPLOYMENT_INFO" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŽ¯ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "- Verify application accessibility" >> $GITHUB_STEP_SUMMARY
          echo "- Check monitoring and logging setup" >> $GITHUB_STEP_SUMMARY
          echo "- Review security configurations" >> $GITHUB_STEP_SUMMARY

  # Cleanup failed deployments
  rollback:
    name: ðŸ”„ Rollback Failed Deployment
    needs: [deploy]
    runs-on: ubuntu-latest
    if: failure() && github.ref == 'refs/heads/deploy'
    steps:
      - name: Restore previous deployment
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USER }}
          key: ${{ env.EC2_PRIVATE_KEY }}
          port: 22
          debug: true
          script: |
            echo "Starting rollback process..."
            
            cd ${{ env.DEPLOYMENT_DIR }}
            
            # Find the most recent backup
            LATEST_BACKUP=$(ls -1t backup-* 2>/dev/null | head -1 || echo "")
            
            if [ -n "$LATEST_BACKUP" ]; then
              echo "Rolling back to: $LATEST_BACKUP"
              
              # Remove failed deployment
              rm -rf current
              
              # Restore from backup
              mv "$LATEST_BACKUP" current
              
              echo "Rollback completed successfully"
              echo "Previous deployment has been restored"
            else
              echo "No backup found for rollback"
              echo "Manual intervention may be required"
            fi

      - name: Cleanup deployment artifacts
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USER }}
          key: ${{ env.EC2_PRIVATE_KEY }}
          port: 22
          debug: true
          script: |
            echo "Cleaning up deployment artifacts..."
            
            cd ${{ env.DEPLOYMENT_DIR }}
            
            # Keep only last 5 backups
            ls -t backup-* 2>/dev/null | tail -n +6 | xargs rm -rf || echo "No old backups to clean"
            
            # Keep only last 10 deployment archives
            cd deployments
            ls -t *.tar.gz 2>/dev/null | tail -n +11 | xargs rm -f || echo "No old archives to clean"
            
            echo "Cleanup completed" 